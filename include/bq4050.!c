#include "bq4050.h"
#include "stdint.h"
#include <stdio.h>

#include "gd32e23x.h"
#include "i2c.h"
#include "systick.h"

void bq_Init()
{
    i2c_config();
}

uint8_t WriteNbyte(uint8_t write_address, uint8_t *p_buffer, uint8_t number_of_byte)
{
    uint8_t state = I2C_START;
    uint16_t timeout = 0;
    uint8_t i2c_timeout_flag = 0;

    /* enable acknowledge */
    i2c_ack_config(I2CX, I2C_ACK_ENABLE);
    while (!(i2c_timeout_flag))
    {
        switch (state)
        {
        case I2C_START:
            /* i2c master sends start signal only when the bus is idle */
            while (i2c_flag_get(I2CX, I2C_FLAG_I2CBSY) && (timeout < I2C_TIME_OUT))
            {
                timeout++;
            }
            if (timeout < I2C_TIME_OUT)
            {
                i2c_start_on_bus(I2CX);
                timeout = 0;
                state = I2C_SEND_ADDRESS;
            }
            else
            {
                i2c_bus_reset();
                timeout = 0;
                state = I2C_START;
                printf("i2c bus is busy in WRITE!\n");
            }
            break;
        case I2C_SEND_ADDRESS:
            /* i2c master sends START signal successfully */
            while ((!i2c_flag_get(I2CX, I2C_FLAG_SBSEND)) && (timeout < I2C_TIME_OUT))
            {
                timeout++;
            }
            if (timeout < I2C_TIME_OUT)
            {
                i2c_master_addressing(I2CX, BQ_ADDR, I2C_TRANSMITTER);
                timeout = 0;
                state = I2C_CLEAR_ADDRESS_FLAG;
            }
            else
            {
                timeout = 0;
                state = I2C_START;
                printf("i2c master sends start signal timeout in WRITE!\n");
            }
            break;
        case I2C_CLEAR_ADDRESS_FLAG:
            /* address flag set means i2c slave sends ACK */
            while ((!i2c_flag_get(I2CX, I2C_FLAG_ADDSEND)) && (timeout < I2C_TIME_OUT))
            {
                timeout++;
            }
            if (timeout < I2C_TIME_OUT)
            {
                i2c_flag_clear(I2CX, I2C_FLAG_ADDSEND);
                timeout = 0;
                state = I2C_TRANSMIT_DATA;
            }
            else
            {
                timeout = 0;
                state = I2C_START;
                printf("i2c master clears address flag timeout in WRITE!\n");
            }
            break;
        case I2C_TRANSMIT_DATA:
            /* wait until the transmit data buffer is empty */
            while ((!i2c_flag_get(I2CX, I2C_FLAG_TBE)) && (timeout < I2C_TIME_OUT))
            {
                timeout++;
            }
            if (timeout < I2C_TIME_OUT)
            {
                /* send the BQ's internal address to write to : only one byte address */
                i2c_data_transmit(I2CX, write_address);
                timeout = 0;
            }
            else
            {
                timeout = 0;
                state = I2C_START;
                printf("i2c master sends BQ's internal address timeout in WRITE!\n");
            }
            /* wait until BTC bit is set */
            while ((!i2c_flag_get(I2CX, I2C_FLAG_BTC)) && (timeout < I2C_TIME_OUT))
            {
                timeout++;
            }
            if (timeout < I2C_TIME_OUT)
            {
                timeout = 0;
            }
            else
            {
                timeout = 0;
                state = I2C_START;
                printf("i2c master sends data timeout in WRITE!\n");
            }
            while (number_of_byte--)
            {
                i2c_data_transmit(I2CX, *p_buffer);
                /* point to the next byte to be written */
                p_buffer++;
                /* wait until BTC bit is set */
                while ((!i2c_flag_get(I2CX, I2C_FLAG_BTC)) && (timeout < I2C_TIME_OUT))
                {
                    timeout++;
                }
                if (timeout < I2C_TIME_OUT)
                {
                    timeout = 0;
                }
                else
                {
                    timeout = 0;
                    state = I2C_START;
                    printf("i2c master sends data timeout in WRITE!\n");
                }
            }
            timeout = 0;
            state = I2C_STOP;
            break;
        case I2C_STOP:
            /* send a stop condition to I2C bus */
            i2c_stop_on_bus(I2CX);
            /* i2c master sends STOP signal successfully */
            while ((I2C_CTL0(I2CX) & I2C_CTL0_STOP) && (timeout < I2C_TIME_OUT))
            {
                timeout++;
            }
            if (timeout < I2C_TIME_OUT)
            {
                timeout = 0;
                state = I2C_END;
                i2c_timeout_flag = I2C_OK;
            }
            else
            {
                timeout = 0;
                state = I2C_START;
                printf("i2c master sends stop signal timeout in WRITE!\n");
            }
            break;
        default:
            state = I2C_START;
            i2c_timeout_flag = I2C_OK;
            timeout = 0;
            printf("i2c master sends start signal in WRITE.\n");
            break;
        }
    }
    return I2C_END;
}

uint8_t ReadNbyte(uint8_t read_address, uint8_t *p_buffer, uint8_t number_of_byte)
{
    uint8_t state = I2C_START;
    uint8_t read_cycle = 0;
    uint16_t timeout = 0;
    uint8_t i2c_timeout_flag = 0;

    /* enable acknowledge */
    i2c_ack_config(I2CX, I2C_ACK_ENABLE);
    while (!(i2c_timeout_flag))
    {
        switch (state)
        {
        case I2C_START:
            if (RESET == read_cycle)
            {
                /* i2c master sends start signal only when the bus is idle */
                while (i2c_flag_get(I2CX, I2C_FLAG_I2CBSY) && (timeout < I2C_TIME_OUT))
                {
                    timeout++;
                }
                if (timeout < I2C_TIME_OUT)
                {
                    /* whether to send ACK or not for the next byte */
                    if (2 == number_of_byte)
                    {
                        i2c_ackpos_config(I2CX, I2C_ACKPOS_NEXT);
                    }
                }
                else
                {
                    i2c_bus_reset();
                    timeout = 0;
                    state = I2C_START;
                    printf("i2c bus is busy in READ!\n");
                }
            }
            /* send the start signal */
            i2c_start_on_bus(I2CX);
            timeout = 0;
            state = I2C_SEND_ADDRESS;
            break;
        case I2C_SEND_ADDRESS:
            /* i2c master sends START signal successfully */
            while ((!i2c_flag_get(I2CX, I2C_FLAG_SBSEND)) && (timeout < I2C_TIME_OUT))
            {
                timeout++;
            }
            if (timeout < I2C_TIME_OUT)
            {
                if (RESET == read_cycle)
                {
                    i2c_master_addressing(I2CX, BQ_ADDR, I2C_TRANSMITTER);
                    state = I2C_CLEAR_ADDRESS_FLAG;
                }
                else
                {
                    i2c_master_addressing(I2CX, BQ_ADDR, I2C_RECEIVER);
                    if (number_of_byte < 3)
                    {
                        /* disable acknowledge */
                        i2c_ack_config(I2CX, I2C_ACK_DISABLE);
                    }
                    state = I2C_CLEAR_ADDRESS_FLAG;
                }
                timeout = 0;
            }
            else
            {
                timeout = 0;
                state = I2C_START;
                read_cycle = 0;
                printf("i2c master sends start signal timeout in READ!\n");
            }
            break;
        case I2C_CLEAR_ADDRESS_FLAG:
            /* address flag set means i2c slave sends ACK */
            while ((!i2c_flag_get(I2CX, I2C_FLAG_ADDSEND)) && (timeout < I2C_TIME_OUT))
            {
                timeout++;
            }
            if (timeout < I2C_TIME_OUT)
            {
                i2c_flag_clear(I2CX, I2C_FLAG_ADDSEND);
                if ((SET == read_cycle) && (1 == number_of_byte))
                {
                    /* send a stop condition to I2C bus */
                    i2c_stop_on_bus(I2CX);
                }
                timeout = 0;
                state = I2C_TRANSMIT_DATA;
            }
            else
            {
                timeout = 0;
                state = I2C_START;
                read_cycle = 0;
                printf("i2c master clears address flag timeout in READ!\n");
            }
            break;
        case I2C_TRANSMIT_DATA:
            if (RESET == read_cycle)
            {
                /* wait until the transmit data buffer is empty */
                while ((!i2c_flag_get(I2CX, I2C_FLAG_TBE)) && (timeout < I2C_TIME_OUT))
                {
                    timeout++;
                }
                if (timeout < I2C_TIME_OUT)
                {
                    /* send the EEPROM's internal address to write to : only one byte address */
                    i2c_data_transmit(I2CX, read_address);
                    timeout = 0;
                }
                else
                {
                    timeout = 0;
                    state = I2C_START;
                    read_cycle = 0;
                    printf("i2c master wait data buffer is empty timeout in READ!\n");
                }
                /* wait until BTC bit is set */
                while ((!i2c_flag_get(I2CX, I2C_FLAG_BTC)) && (timeout < I2C_TIME_OUT))
                {
                    timeout++;
                }
                if (timeout < I2C_TIME_OUT)
                {
                    timeout = 0;
                    state = I2C_START;
                    read_cycle++;
                }
                else
                {
                    timeout = 0;
                    state = I2C_START;
                    read_cycle = 0;
                    printf("i2c master sends BQ's internal address timeout in READ!\n");
                }
            }
            else
            {
                while (number_of_byte)
                {
                    timeout++;
                    if (3 == number_of_byte)
                    {
                        /* wait until BTC bit is set */
                        while (!i2c_flag_get(I2CX, I2C_FLAG_BTC))
                            ;
                        /* disable acknowledge */
                        i2c_ack_config(I2CX, I2C_ACK_DISABLE);
                    }
                    if (2 == number_of_byte)
                    {
                        /* wait until BTC bit is set */
                        while (!i2c_flag_get(I2CX, I2C_FLAG_BTC))
                            ;
                        /* send a stop condition to I2C bus */
                        i2c_stop_on_bus(I2CX);
                    }
                    /* wait until RBNE bit is set */
                    if (i2c_flag_get(I2CX, I2C_FLAG_RBNE))
                    {
                        /* read a byte from the EEPROM */
                        *p_buffer = i2c_data_receive(I2CX);
                        /* point to the next location where the byte read will be saved */
                        p_buffer++;
                        /* decrement the read bytes counter */
                        number_of_byte--;
                        timeout = 0;
                    }
                    if (timeout > I2C_TIME_OUT)
                    {
                        timeout = 0;
                        state = I2C_START;
                        read_cycle = 0;
                        printf("i2c master sends data timeout in READ!\n");
                    }
                }
                timeout = 0;
                state = I2C_STOP;
            }
            break;
        case I2C_STOP:
            /* i2c master sends STOP signal successfully */
            while ((I2C_CTL0(I2CX) & I2C_CTL0_STOP) && (timeout < I2C_TIME_OUT))
            {
                timeout++;
            }
            if (timeout < I2C_TIME_OUT)
            {
                timeout = 0;
                state = I2C_END;
                i2c_timeout_flag = I2C_OK;
            }
            else
            {
                timeout = 0;
                state = I2C_START;
                read_cycle = 0;
                printf("i2c master sends stop signal timeout in READ!\n");
            }
            break;
        default:
            state = I2C_START;
            read_cycle = 0;
            i2c_timeout_flag = I2C_OK;
            timeout = 0;
            printf("i2c master sends start signal in READ.\n");
            break;
        }
    }
    return I2C_END;
}

void bq_MACReadBlock(uint8_t *inBlock, uint8_t inLen, uint8_t *outBlock, uint8_t outLen)
{
	uint8_t retryCnt = 100;
    while (1)
    {
        WriteNbyte(0x44, inBlock, inLen);
        ReadNbyte(0x44, outBlock, outLen);
        if (inBlock[1] == outBlock[1] && inBlock[2] == outBlock[2])
        {
            break;
        }
				delay_1ms(20);
    }
}

uint8_t bq_BattState() // Return CHG/DSG(0xC?/0x0?), OK/Bad(0x0?/0x3?), TCTDFCFD(bit3 2 1 0)
{
    uint8_t battStatus[2], battDataBuf[7], ret = 0x00;
    uint8_t battCmd[3] = {0x02, 0x50, 0x00}; // SafetyAlert MAC Cmd
    ReadNbyte(0x16, battStatus, 2);
    ret |= (((battStatus[0] & 0x40) == 0x40) ? 0x00 : 0xc0);
    bq_MACReadBlock(battCmd, 3, battDataBuf, 7);
    battDataBuf[6] &= 0x0f; // Clear RSVD
    battDataBuf[5] &= 0xfd;
    battDataBuf[4] &= 0x7a;
    battDataBuf[3] &= 0xbf;
    if ((battDataBuf[3] | battDataBuf[4] | battDataBuf[5] | battDataBuf[6]) != 0)
    {
        ret |= 0x30;
        return ret;
    }
    battCmd[1] = 0x54;
    bq_MACReadBlock(battCmd, 3, battDataBuf, 7);
    if ((battDataBuf[4] & 0x60) != 0)
    {
        ret |= 0x30;
    }
    battCmd[1] = 0x51;
    bq_MACReadBlock(battCmd, 3, battDataBuf, 7);
    battDataBuf[6] &= 0x0f; // Clear RSVD
    battDataBuf[5] &= 0xd5;
    battDataBuf[4] &= 0x7f;
    battDataBuf[3] &= 0xff;
    if ((battDataBuf[3] | battDataBuf[4] | battDataBuf[5] | battDataBuf[6]) != 0)
    {
        ret |= 0x30;
    }
    battCmd[1] = 0x56;
    bq_MACReadBlock(battCmd, 3, battDataBuf, 5);
    ret |= (battDataBuf[3] & 0x0f);
    return ret;
}

uint16_t bq_GetAdvState()
{ // Return XDSG/XCHG/PF/SS  FC/FD/TAPR/VCT  CB/SMTH/SU/IN  VDQ/FCCX/EDV2/EDV1
    uint16_t ret = 0x0000;
    uint8_t battDataBuf[7], battCmd[3] = {0x02, 0x54, 0x00}; // OperationStatus MAC Cmd
    bq_MACReadBlock(battCmd, 3, battDataBuf, 7);
    ret |= ((battDataBuf[3] & 0x40) == 0x40) ? (uint16_t)1 << 6 : 0;  // SMTH
    ret |= ((battDataBuf[4] & 0x08) == 0x08) ? (uint16_t)1 << 12 : 0; // SS
    ret |= ((battDataBuf[4] & 0x10) == 0x10) ? (uint16_t)1 << 13 : 0; // PF
    ret |= ((battDataBuf[4] & 0x20) == 0x20) ? (uint16_t)1 << 15 : 0; // XDSG
    ret |= ((battDataBuf[4] & 0x40) == 0x40) ? (uint16_t)1 << 14 : 0; // XCHG
    ret |= ((battDataBuf[6] & 0x10) == 0x10) ? (uint16_t)1 << 7 : 0;  // CB
    battCmd[1] = 0x55;                                                // ChargingStatus MAC Cmd
    bq_MACReadBlock(battCmd, 3, battDataBuf, 6);
    ret |= ((battDataBuf[3] & 0x10) == 0x10) ? (uint16_t)1 << 4 : 0; // IN
    ret |= ((battDataBuf[3] & 0x20) == 0x20) ? (uint16_t)1 << 5 : 0; // SU
    ret |= ((battDataBuf[3] & 0x80) == 0x80) ? (uint16_t)1 << 8 : 0; // VCT
    ret |= ((battDataBuf[4] & 0x80) == 0x80) ? (uint16_t)1 << 9 : 0; // TAPR
    battCmd[1] = 0x56;                                               // GaugingStatus MAC Cmd
    bq_MACReadBlock(battCmd, 3, battDataBuf, 5);
    ret |= ((battDataBuf[3] & 0x01) == 0x01) ? (uint16_t)1 << 10 : 0; // FD
    ret |= ((battDataBuf[3] & 0x02) == 0x02) ? (uint16_t)1 << 11 : 0; // FC
    ret |= ((battDataBuf[4] & 0x04) == 0x04) ? (uint16_t)1 << 2 : 0;  // FCCX
    ret |= ((battDataBuf[4] & 0x20) == 0x20) ? (uint16_t)1 << 0 : 0;  // EDV1
    ret |= ((battDataBuf[4] & 0x40) == 0x40) ? (uint16_t)1 << 1 : 0;  // EDV2
    ret |= ((battDataBuf[4] & 0x80) == 0x80) ? (uint16_t)1 << 3 : 0;  // VDQ

    return ret;
}

uint16_t bq_GetVoltage()
{ // Unit: mV
    uint8_t battBuf[2];
    uint16_t battVolt;
    ReadNbyte(0x09, battBuf, 2);
    battVolt = (battBuf[1] << 8) + battBuf[0];
    return battVolt;
}

int16_t bq_GetCurrent()
{ // Unit: mA
    uint8_t battBuf[2];
    int16_t battCurrent;
    ReadNbyte(0x0A, battBuf, 2);
    *((uint8_t *)&battCurrent) = battBuf[0];
    *((uint8_t *)(&battCurrent) + 1) = battBuf[1];
    return battCurrent;
}

uint8_t bq_GetRSOC()
{ // Unit: %
    uint8_t battBuf[2];
    ReadNbyte(0x0D, battBuf, 2);
    return battBuf[0];
}

uint16_t bq_GetT2E()
{ // Unit: min
    uint8_t battBuf[2];
    uint16_t battT2E;
    ReadNbyte(0x12, battBuf, 2);
    battT2E = (battBuf[1] << 8) + battBuf[0];
    return battT2E;
}

uint16_t bq_GetT2F()
{ // Unit: min
    uint8_t battBuf[2];
    uint16_t battT2F;
    ReadNbyte(0x13, battBuf, 2);
    battT2F = (battBuf[1] << 8) + battBuf[0];
    return battT2F;
}

uint16_t bq_GetPackTemp()
{ // Unit: 0.1K
    uint8_t battBuf[2];
    uint16_t battPackTemp;
    ReadNbyte(0x08, battBuf, 2);
    battPackTemp = (battBuf[1] << 8) + battBuf[0];
    return battPackTemp;
}

uint8_t bq_GetMaxErr()
{ // Unit: %
    uint8_t battBuf[2];
    ReadNbyte(0x0C, battBuf, 2);
    return battBuf[0];
}

uint8_t bq_GetHealth()
{ // Unit: %
    uint8_t battBuf[2];
    uint16_t battFCC, battDC;
    float battHealth;
    ReadNbyte(0x10, battBuf, 2);
    battFCC = (battBuf[1] << 8) + battBuf[0];
    ReadNbyte(0x18, battBuf, 2);
    battDC = (battBuf[1] << 8) + battBuf[0];
    battHealth = ((float)battFCC * 100.0f / (float)battDC);
    return (battHealth >= 100.0f ? 100 : (uint8_t)battHealth);
}

uint16_t bq_GetCellVolt(uint8_t cellNo)
{ // Unit: mV
    uint8_t battBuf[2], cmd = 0x40;
    uint16_t battCellVolt;
    if (cellNo > 4 || cellNo < 1)
        return 0;
    cmd -= cellNo;
    ReadNbyte(cmd, battBuf, 2);
    battCellVolt = (battBuf[1] << 8) + battBuf[0];
    return battCellVolt;
}

uint16_t bq_GetCycleCnt()
{
    uint8_t battBuf[2];
    uint16_t battCycleCnt;
    ReadNbyte(0x17, battBuf, 2);
    battCycleCnt = (battBuf[1] << 8) + battBuf[0];
    return battCycleCnt;
}

void bq_GetLifetimeBlock(uint8_t blockNo, uint8_t *blockBuf)
{
    uint8_t blockBufLen = 3, battCmd[3] = {0x02, 0x60, 0x00}; // LifetimeDataBlockN MAC Cmd
    battCmd[1] += (blockNo - 1);
    switch (blockNo)
    {
    case 1:
    case 4:
        blockBufLen += 32;
        break;
    case 2:
        blockBufLen += 8;
        break;
    case 3:
        blockBufLen += 16;
        break;
    case 5:
        blockBufLen += 20;
        break;
    default:
        return;
    }
    bq_MACReadBlock(battCmd, 3, blockBuf, blockBufLen);
}
